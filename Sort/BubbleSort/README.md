# 冒泡排序

## 前言

如果说各种各样的编程语言是五花八门的招式，那么数据结构和算法就是程序员的内功了，这也是为什么各种招聘面试永远不会冷落这些的原因。而排序作为数据结构一个重要组成。所谓排序，就是将一组无序的数据整理成为有序的序列的过程。

## 排序分类
一般而言，排序分为内部排序和外部排序。
- 若整个排序过程不需要访问外存便能够完成，这类排序称为内部排序。
- 若数据量很大，排序不可能在内存中完成，这类排序称为外部排序。

![](http://g.recordit.co/trYo9qaS2b.gif)

## 冒泡排序

冒泡排序是一种交换排序，交换排序的基本思想是：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个序列都满足次序要求为止。

- 以升序为例，对n个数据，共进行n轮排序，每一轮两两比较相邻元素，将小的放到前面大的放到后面，每一轮结果是将当前最大的元素移动到序列最后。
- 由于每一轮排序当前最大的元素到达序列的最底部，越小的元素慢慢浮动到序列的顶部，故名冒泡排序。

**代码实现**

这个排序实现并不是很难，用Python实现如下。

```python
def bubble_sort(data):
    for i in range(len(data)-1):
        print("第{}趟排序".format(i))
        for j in range(len(data)-1-i):
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j]
        print("当前排序结果为:", data)
    return None
 
test_data = [1, 3, 5, 7, 9, 8, 6, 4, 2]
print("原来数据", test_data)
bubble_sort(test_data)
```

它有如下的执行结果。

```
原来数据 [1, 3, 5, 7, 9, 8, 6, 4, 2]
第0趟排序
当前排序结果为: [1, 3, 5, 7, 8, 6, 4, 2, 9]
第1趟排序
当前排序结果为: [1, 3, 5, 7, 6, 4, 2, 8, 9]
第2趟排序
当前排序结果为: [1, 3, 5, 6, 4, 2, 7, 8, 9]
第3趟排序
当前排序结果为: [1, 3, 5, 4, 2, 6, 7, 8, 9]
第4趟排序
当前排序结果为: [1, 3, 4, 2, 5, 6, 7, 8, 9]
第5趟排序
当前排序结果为: [1, 3, 2, 4, 5, 6, 7, 8, 9]
第6趟排序
当前排序结果为: [1, 2, 3, 4, 5, 6, 7, 8, 9]
第7趟排序
当前排序结果为: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

显然，分析冒泡排序的算法复杂度如下。
	
| 排序名称 | 最好情况 | 最坏情况 | 平均情况 |
| :---: | :---: | :---: | :---: |
| 冒泡排序 | O(n) | O(n^2) | O(n^2) |

也就是说，这个算法是可以优化的，一旦序列基本有序，只需要进行少数轮次排序就可以实现，后面的轮次是多余的，这也是很多面试官喜欢问到的。

优化后的代码如下所示，只有添加一个flag监控该趟是否交换，一旦某一趟排序没有交换，就认为排序可以结束了。
	
> 任何时候，在空间复杂度没有太大优化空间时，优化时间复杂度是一个永恒不变的话题。

```python
def bubble_sort_optimized(data):
    for i in range(len(data)-1):
        flag = False
        print("第{}趟排序".format(i))
        for j in range(len(data)-i-1):
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j]
                flag = True
        if flag is False:
            break
        print("当前排序结果为:", data)
    return None
test_data = [1, 2, 3, 4, 5, 6, 7, 9, 8]
print("原来数据", test_data)
bubble_sort_optimized(test_data)
```

它有如下的执行结果。

```
原来数据 [1, 2, 3, 4, 5, 6, 7, 9, 8]
第0趟排序
当前排序结果为: [1, 2, 3, 4, 5, 6, 7, 8, 9]
第1趟排序
```

更加详细可以查看我的Github仓库，欢迎star或者fork。
